# 后缀自动机 SAM

## 0.前提紧要：有限状态机FSA

- **定义**：有限状态机（Finite State Machine, FSM）是一种抽象计算模型，用于设计算法和系统。它由一组**状态**、状态之间的**转移**和每个转移所对应的**动作**组成。在任何时刻，有限状态机都处于一种状态。根据输入或其他触发事件，它可以从一种状态转换到另一种状态，这个过程称为状态转移。

- **组成部分**：

  >- **状态（States）**：系统所有可能所处的情形。有限状态机的状态是有限的。`每一个圆圈`
  >- **初始状态（Initial state）**：系统启动时所处的状态。`圈0`
  >- **输入（Input）**：导致转换或者输出动作的事件或符号序列。`线上的a,b`
  >- **转移函数（Transition function）**：定义了基于当前状态和给定输入，系统如何转移到下一个状态。`箭头线`
  >- **接受状态（Accepting states）**：对于接受型的有限状态机（如用于模式匹配的有限状态机），定义了哪些状态被视为接受输入的结束状态。`双圆圈`
  >- **输出（Output）**：系统在某些状态下或在某些转移时可能会有的响应（在输出有限状态机或Mealy机型中）。`此处无`
  >- **例子**：1. `只接受任何 "ab*" 的输入（下图）`   2. `按压式圆珠笔，由"按下+收笔"=>"出笔"，由"按下+出笔"=>"收笔"`

  <img src="image\FSA.png" alt="FSA" style="zoom:50%;" />

- **工作原理**：由**1.当前状态**和**2.当前输入**，采取**1.停留**和**2.转移**两种动作

- 参考：https://youtu.be/4rNYAvsSkwk?si=sGwxjdCkQcxVrQzm

### 非确定性有限自动机 NFA

- **定义**：非确定性有限自动机（Nondeterministic Finite Automaton, NFA）是有限状态机的一种，它对于给定的状态和输入符号，可以**转移到多个新状态**，即下一个状态不是唯一确定的。NFA 是一种理论上的机器，用于在形式语言理论中研究和描述字符串的模式。

- **与DFA区别**：

  - **非确定性**：NFA 允许从一个状态和输入符号出发有多个可能的转移。也就是说，在读取一个输入符号后，NFA 可能会转移到多个不同的状态。
  - **ε转移**：NFA 允许所谓的 ε（epsilon）转移，也就是在不读取任何输入符号的情况下的状态转移。这允许NFA即使没有输入也能改变状态。

- **组成部分**：

  >- **状态集合**：所有可能状态的集合。
  >- **输入字母表**：所有可能输入的集合。
  >- **转移函数**：描述了状态间如何根据输入或ε进行转移。
  >- **初始状态**：NFA 开始工作时所处的状态。
  >- **接受状态集合**：当字符串被处理完毕时，如果NFA处于接受状态集合中的任何一个状态，则该字符串被接受。

- **工作原理**：NFA 在每一步都可能有多个合法的状态转移。因此，NFA 可以同时沿着多条路径进行计算，这就是“非确定性”的含义。实际上，NFA 在计算时并不是真的同时在多个状态，而是理论上存在多种可能的状态序列。如果任何一条这样的路径最终达到了接受状态，那么输入字符串就被接受。

- **例子**：

  >设想一个接受二进制字符串，该字符串中至少包含一次“01”序列的 NFA。可以构建如下：
  >
  >- **状态**：{q0, q1, q2}，其中 q2 是接受状态。
  >
  >- **初始状态**：q0
  >
  >- **输入字母表**：{0, 1}
  >
  >- 转移函数
  >
  >  ：
  >
  >  - 从 q0 读取 0 可以留在 q0 或者转移到 q1。
  >  - 从 q1 读取 1 必须转移到 q2。
  >  - q2 是接受状态，到达这里之后无论读取何种字符都留在 q2。
  >
  >在这个 NFA 中，一旦读取到“01”序列，就会从 q1 转移到 q2，且之后无论读取何值都将停留在接受状态 q2，表示接受该字符串。

### 确定性有限自动机 DFA

- **定义**:确定性有限自动机 （Deterministic Finite Automaton, DFA）是计算机科学中一种模型，用于表示有限状态机的一种特殊类型。在DFA中，对于每个状态和每个可能的输入符号，都有一条明确的路径指向下一个状态。这意味着，给定当前的状态和输入的符号，DFA可以确定要转移到哪个状态，而不会产生混淆或多个可能的状态。

- **组成部分**：

  > 1. **状态集**（States）：定义了自动机的所有可能的状态。
  > 2. **字母表**（Alphabet）：DFA可以接受的输入符号的集合。
  > 3. **转移函数**（Transition Function）：定义了状态与输入符号之间的关系。对于DFA的每个状态和字母表中的每个符号，转移函数都指定了自动机应该转移到的单一状态。
  > 4. **初始状态**（Initial State）：DFA开始处理输入字符串时的状态。
  > 5. **接受状态集**（Accepting States）：一旦所有输入符号都被读取完毕，如果DFA在接受状态集中的任一状态，输入字符串被接受；否则，被拒绝。

- **工作原理**：DFA从初始状态开始，读取输入字符串的符号。对于每个读入的符号，它根据当前状态和转移函数确定下一个状态。这一过程持续进行，直到字符串全部被读取。如果最终DFA处于接受状态，输入字符串就被接受；如果不在接受状态，则字符串被拒绝。

- **例子**：参考FSA

- 参考：https://youtu.be/cwWkw8gNCcA?si=aXoDn39_8GTY7bBS

## 1.定义

后缀自动机（Suffix Automaton, SAM）是字符串的最小状态有限自动机，它能够接受该字符串的所有后缀。换句话说，对于字符串 S，后缀自动机是识别字符串 S 的所有可能后缀的最简化的有限状态机。SAM 对于字符串搜索和处理问题特别有效，因为它允许在线性时间复杂度内构建，并支持在线性时间内进行搜索查询。

## 2.组成

SAM 由状态（states）和转移（transitions）组成。每个状态代表一个或多个后缀，而每个转移对应在某个后缀后添加一个字符。

- **状态**：在 SAM 中，每个状态实际上代表着一些字符串的结束位置。有两种状态：
  - **初始状态**：表示一个空的后缀。
  - **其它状态**：代表一个或多个后缀的结束位置。
- **转移**：如果存在一个从状态 s 到状态 t 的转移，并且这个转移上的字符是 c，这意味着如果在 s 状态代表的字符串后面添加字符 c，你会得到 t 状态代表的字符串。
- **链接（link）**：每个状态 s 有一个链接到另一个状态 p，其中 p 是 s 的最长的可行后缀，但长度严格小于 s。

## 3.性质

- 每个后缀都对应一条从初始状态开始的路径。
- 如果一个字符串 x 是另一个字符串 y 的后缀，那么 y 在 SAM 中的路径一定会经过 x 的路径的最后一个状态。
- 两个状态之间可能存在多个转移，但每个转移对应不同的字符。

## 4.简单例子

> 字符串 "aba" 的所有后缀包括："a", "ba", "aba"。构建 SAM 的过程涉及逐步添加字符串的每个字符，并适当地更新状态和转移。
>
> ### 初始状态：
>
> 1. **开始**时，我们有一个初始状态 0（通常表示空字符串）。每个状态都可能有指向其他状态的转移，这些转移由字符标记。
>
> ### 添加第一个字符 'a'：
>
> 1. 当我们添加第一个字符 'a' 时，我们创建一个新状态 1，并从状态 0 添加一个标记为 'a' 的转移至状态 1。现在，状态 1 表示字符串 "a"。
>
> ### 添加第二个字符 'b'：
>
> 1. 接下来，添加字符 'b'。我们创建一个新状态 2，并从状态 1 添加一个标记为 'b' 的转移至状态 2。同时，我们还需要从状态 0 添加一个转移至状态 2，因为 "b" 也是一个有效后缀。现在，状态 2 表示字符串 "ab" 和 "b"。
>
> ### 添加第三个字符 'a'：
>
> 1. 最后，我们添加第三个字符 'a'。我们创建一个新状态 3，并从状态 2 添加一个标记为 'a' 的转移至状态 3。我们还需要考虑字符串 "a" 的情况，因此从状态 0 和状态 1 分别添加转移至状态 3，因为通过添加这个 'a'，"a" 和 "ba" 都变成了有效的后缀。现在，状态 3 表示字符串 "aba", "ba", 和 "a"。
>
> ### 结果：
>
> 通过上述步骤，我们得到了一个能够接受字符串 "aba" 所有后缀的后缀自动机。这个自动机有4个状态（包括初始状态）和由输入字符 'a' 和 'b' 标记的转移。

## 5.参考

https://oi-wiki.org/string/sam/

## 6.题目

https://www.luogu.com.cn/problem/P3804

https://loj.ac/problem/2033

https://www.spoj.com/problems/LCS/en/

https://www.spoj.com/problems/LCS2/
